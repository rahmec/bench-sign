3,12d2
<  * Reference ISO-C11 Implementation of LESS.
<  *
<  * @version 1.2 (February 2025)
<  *
<  * @author Alessandro Barenghi <alessandro.barenghi@polimi.it>
<  * @author Gerardo Pelosi <gerardo.pelosi@polimi.it>
<  * @author Floyd Zweydinger <zweydfg8+github@rub.de>
<  *
<  * This code is hereby placed in the public domain.
<  *
59,70d48
< /* right-multiplies a generator by a monomial */
< void generator_monomial_mul(generator_mat_t *res,
<                             const generator_mat_t *const G,
<                             const monomial_t *const monom) {
<    for(uint32_t src_col_idx = 0; src_col_idx < N; src_col_idx++) {
<       for(uint32_t row_idx = 0; row_idx < K; row_idx++) {
<          res->values[row_idx][monom->permutation[src_col_idx]] =
<             fq_mul(G->values[row_idx][src_col_idx], monom->coefficients[src_col_idx]);
<       }
<    }
< } /* end generator_monomial_mul */
< 
229,296d206
< /// NOTE: not constant time
< /// \param res[out]: G*c a generator matrix: K \times N-K
< /// \param G[in]: current generator matrix: K \times N-K
< /// \param c[in]: compressed cf action
< void apply_cf_action_to_G(generator_mat_t* res,
<                           const generator_mat_t *G,
<                           const uint8_t *const c) {
<     uint32_t l = 0, r = 0;
<     for (uint32_t i = 0; i < N8; i++) {
<         for (uint32_t j = 0; j < 8; j++) {
<             if ((i*8 + j) >= N) { goto finish; }
< 
<             const uint8_t bit = (c[i] >> j) & 1u;
<             uint32_t pos;
<             if (bit) {
<                 pos = l;
<                 l += 1;
<             } else {
<                 pos = K + r;
<                 r += 1;
<             }
< 
<             // copy the column
<             for (uint32_t k = 0; k < K; k++) {
<                 res->values[k][pos] = G->values[k][i*8 + j];
<             }
<         }
<     }
< finish:
<     return;
< }
< 
< /// NOTE: not constant time
< /// \param res[out]: G*c a generator matrix: K \times N-K
< /// \param G[in]: current generator matrix: K \times N-K
< /// \param c[in]: compressed cf action
< void apply_cf_action_to_G_with_pivots(generator_mat_t* res,
<                                       const generator_mat_t *G,
<                                       const uint8_t *const c,
<                                       const uint8_t initial_G_col_pivot[N],
<                                       uint8_t permuted_G_col_pivot[N]) {
<     uint32_t l = 0, r = 0;
<     for (uint32_t i = 0; i < N8; i++) {
<         for (uint32_t j = 0; j < 8; j++) {
<             if ((i*8 + j) >= N) { goto finish; }
< 
<             const uint8_t bit = (c[i] >> j) & 1u;
<             uint32_t pos;
<             if (bit) {
<                 pos = l;
<                 l += 1;
<             } else {
<                 pos = K + r;
<                 r += 1;
<             }
< 
<             permuted_G_col_pivot[pos] = initial_G_col_pivot[i*8+j];
< 
<             // copy the column
<             for (uint32_t k = 0; k < K; k++) {
<                 res->values[k][pos] = G->values[k][i*8 + j];
<             }
<         }
<     }
< finish:
<     return;
< }
< 
313a224,238
> 
> void generator_rref_compact_speck(FQ_ELEM compact[K][K_pad],
>                             const generator_mat_t *const full,
>                             const uint8_t is_pivot_column[N]) {
>     int dst_col_idx = 0;
>     for (uint32_t src_col_idx = 0; src_col_idx < N; src_col_idx++) {
>         if (!is_pivot_column[src_col_idx]) {
>             for (uint32_t row_idx = 0; row_idx < K; row_idx++) {
>                 compact[row_idx][dst_col_idx] = full->values[row_idx][src_col_idx];
>             }
>             dst_col_idx++;
>         }
>     }
> } /* end generator_rref_compact */
> 
532,537d456
< // V1 =V2
< void normalized_copy(normalized_IS_t *V1,
<                      const normalized_IS_t *V2) {
<     memcpy(V1->values, V2->values, sizeof(normalized_IS_t));
< }
< 
556,560c475
<     SHAKE_STATE_STRUCT csprng_state;
<     initialize_csprng(&csprng_state, seed, SEED_LENGTH_BYTES);
<     for (uint32_t i = 0; i < K; i++) {
<         rand_range_q_state_elements(&csprng_state, res->values[i], N - K);
<     }
---
>     antiorthogonal_sample(res->values,seed);
564a480,975
> 
> 
> void set_row(FQ_ELEM A[K_pad], const FQ_ELEM row[K_pad]){
>     memcpy(A, row, sizeof(FQ_ELEM) * K_pad);
> }
> 
> void row_mat_mult(FQ_ELEM *out,
>                     const FQ_ELEM *row,
>                     FQ_ELEM M[K][K_pad],
>                     uint8_t r,
>                     uint8_t c){
>     for(uint8_t i=0; i<c; i++){
>         out[i] = 0;
>         for(uint8_t j=0; j<r; j++){
>             out[i] = fq_add(out[i],fq_mul(row[j],M[j][i])); 
>         }
>     }
> }
> 
> 
> void swap_columns(FQ_ELEM M[K][K_pad], uint8_t c1, uint8_t c2, uint8_t r){
>     FQ_ELEM tmp;
>     for(uint8_t i=0; i<r; i++){
>         tmp = M[i][c1];
>         M[i][c1] = M[i][c2];
>         M[i][c2] = tmp;
>     }
> }
> 
> /// \param res[out]: full rank generator matrix K \times K
> /// \param seed[int] seed for the prng
> void antiorthogonal_sample(FQ_ELEM A[K][K_pad], const unsigned char seed[SEED_LENGTH_BYTES]) {
>     SHAKE_STATE_STRUCT csprng_state;
>     initialize_csprng(&csprng_state, seed, SEED_LENGTH_BYTES);
>     FQ_ELEM G[K][K_pad];
>     FQ_ELEM c[K] = {0};
>     FQ_ELEM c_in_prod = 0;
>     inner_prod(&c_in_prod, c);
> 
>     while(c[0] == 0 || c_in_prod != 126){
>         rand_range_q_state_elements(&csprng_state, c, K);
>         if(c[0] != 0){
>             anti_normalize(c);
>             inner_prod(&c_in_prod, c);
>         }
>     }
> 
>     set_row(A[0],c);
>     row_mul(c,fq_inv(c[0]));
>     set_row(G[0],c);
> 
>     FQ_ELEM M[K][K_pad];
>     uint8_t kp = 1;
> 
>     while (kp < K) {
> 
>         for(uint8_t i=0; i<K-kp; i++){
>             for(uint8_t j=0; j<kp; j++){
>                 M[i][j] = fq_sub(0,G[j][i+kp]);
>             }
>         }
> 
>         FQ_ELEM u[K-kp];
> 
>         do{
>             rand_range_q_state_elements(&csprng_state, u, K-kp);
>             row_mat_mult(c,u,M,K-kp,kp);
>             for(uint8_t i=0; i<K-kp; i++){
>                 c[kp+i] = u[i];
>             }
>             anti_normalize(c);
>             inner_prod(&c_in_prod, c);
>         }while(c_in_prod != 126);
> 
>         set_row(A[kp],c);
>         set_row(G[kp],c);
>         for(uint8_t i=0; i<kp; i++){
>             if(G[kp][i] != 0){
>                 row_sum(G[kp],G[i],fq_sub(0,G[kp][i]),K);
>             }
>         }
> 
>         if(G[kp][kp] == 0){
>             for(uint8_t i=kp+1; i<K; i++){
>                 if(G[kp][i] != 0){
>                     swap_columns(G,kp,i,kp+1);
>                     swap_columns(A,kp,i,kp+1);
>                     break;
>                 }
>             }
>         }
>         
>         row_mul(G[kp],fq_inv(G[kp][kp]));
> 
>         for(int i=0; i<kp; i++){
>             if(G[i][kp] != 0){
>                 row_sum(G[i], G[kp], fq_sub(0,G[i][kp]), K);
>             }
>         }
> 
>         kp += 1;
>     }
> }
> 
> /* permutes generator columns */
> void permute_generator(generator_mat_t *res,
>                         const generator_mat_t *const G,
>                         const permutation_t *const perm) {
>    for(uint32_t col_idx = 0; col_idx < N; col_idx++) {
>       for(uint32_t row_idx = 0; row_idx < K; row_idx++) {
>          res->values[row_idx][col_idx] = G->values[row_idx][perm->values[col_idx]];
>       }
>    }
> } 
> 
> /* permutes a codeword */
> void permute_codeword(FQ_ELEM res[N],
>                         const FQ_ELEM to_perm[N],
>                         const permutation_t *const perm) {
>    for(uint32_t col_idx = 0; col_idx < N; col_idx++) {
>          res[col_idx] = to_perm[perm->values[col_idx]];
>     }
> } 
> 
> /* seems constant time */
> void generate_rref_perm(permutation_t *res,
>                         uint8_t is_pivot_column[N]){
>         POSITION_T ctr_is = 0;
>         POSITION_T ctr_non_is = 0;
>         for(uint8_t i=0; i<N; i++){
>             if(is_pivot_column[i] == 1){
>                res->values[ctr_is] = i; 
>                ctr_is++;
>             } else {
>                res->values[K+ctr_non_is] = i; 
>                ctr_non_is++;
>             }
>         }
> }
> 
> /* Compresses a generator matrix in RREF into an array of bytes */
> void compress_rref_speck(uint8_t *compressed,
>                    const generator_mat_t *const full,
>                    const uint8_t is_pivot_column[N]) {
>     int compress_idx = 0;
> 
>     // Compress non-pivot columns row-by-row
>     int encode_state = 0;
>     for (uint32_t row_idx = 0; row_idx < K; row_idx++) {
>         for (uint32_t col_idx = 0; col_idx < N; col_idx++) {
>             if (!is_pivot_column[col_idx]) {
>                 switch (encode_state) {
>                     case 0:
>                         compressed[compress_idx] = full->values[row_idx][col_idx];
>                         break;
>                     case 1:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 7);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 1);
>                         break;
>                     case 2:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 6);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 2);
>                         break;
>                     case 3:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 5);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 3);
>                         break;
>                     case 4:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 4);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 4);
>                         break;
>                     case 5:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 3);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 5);
>                         break;
>                     case 6:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 2);
>                         compress_idx++;
>                         compressed[compress_idx] = (full->values[row_idx][col_idx] >> 6);
>                         break;
>                     case 7:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (full->values[row_idx][col_idx] << 1);
>                         compress_idx++;
>                         break;
>                 }
> 
>                 if (encode_state != 7) {
>                     encode_state++;
>                 } else {
>                     encode_state = 0;
>                 }
>             }
>         }
>     } /* end compress_rref */
> }
> 
> /* Expands a compressed RREF generator matrix into a full one */
> void expand_to_rref_speck(rref_generator_mat_t *matr,
>                     const uint8_t *compressed) {
>     int compress_idx = 0;
> 
>     // Decompress columns row-by-row
>     int decode_state = 0;
>     for (uint32_t row_idx = 0; row_idx < K; row_idx++) {
>         for (uint32_t col_idx = 0; col_idx < K; col_idx++) {
>                 // Decompress non-pivot
>                 switch (decode_state) {
>                     case 0:
>                         matr->values[row_idx][col_idx] = compressed[compress_idx] & MASK_Q;
>                         break;
>                     case 1:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 7) |
>                                  (compressed[compress_idx + 1] << 1)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 2:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 6) |
>                                  (compressed[compress_idx + 1] << 2)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 3:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 5) |
>                                  (compressed[compress_idx + 1] << 3)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 4:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 4) |
>                                  (compressed[compress_idx + 1] << 4)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 5:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 3) |
>                                  (compressed[compress_idx + 1] << 5)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 6:
>                         matr->values[row_idx][col_idx] =
>                                 ((compressed[compress_idx] >> 2) |
>                                  (compressed[compress_idx + 1] << 6)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 7:
>                         matr->values[row_idx][col_idx] =
>                                 (compressed[compress_idx] >> 1) & MASK_Q;
>                         compress_idx++;
>                         break;
>                 }
> 
>                 if (decode_state != 7) {
>                     decode_state++;
>                 } else {
>                     decode_state = 0;
>                 }
>         }
>     }
> 
> } /* end expand_to_rref */
> 
> void sample_codeword_rref(FQ_ELEM c[N],rref_generator_mat_t G){
>     FQ_ELEM c1[K];
>     FQ_ELEM u[K];
>     rand_range_q_elements(u, K);
>     row_mat_mult(c1,u,G.values,K,K);
>     for(uint8_t i=0; i<K; i++){
>         c[i] = u[i];
>     }
>     for(uint8_t i=0; i<K; i++){
>         c[K+i] = c1[i];
>     }
> }
> 
> /* Compresses a generator matrix in RREF into an array of bytes */
> void compress_rref_speck_non_IS(uint8_t *compressed,
>                    const rref_generator_mat_t *const G_rref) {
>     int compress_idx = 0;
> 
>     // Compress non-pivot columns row-by-row
>     int encode_state = 0;
>     for (uint32_t row_idx = 0; row_idx < K; row_idx++) {
>         for (uint32_t col_idx = 0; col_idx < K; col_idx++) {
>                 switch (encode_state) {
>                     case 0:
>                         compressed[compress_idx] = G_rref->values[row_idx][col_idx];
>                         break;
>                     case 1:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 7);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 1);
>                         break;
>                     case 2:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 6);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 2);
>                         break;
>                     case 3:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 5);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 3);
>                         break;
>                     case 4:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 4);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 4);
>                         break;
>                     case 5:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 3);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 5);
>                         break;
>                     case 6:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 2);
>                         compress_idx++;
>                         compressed[compress_idx] = (G_rref->values[row_idx][col_idx] >> 6);
>                         break;
>                     case 7:
>                         compressed[compress_idx] =
>                                 compressed[compress_idx] | (G_rref->values[row_idx][col_idx] << 1);
>                         compress_idx++;
>                         break;
>                 }
> 
>                 if (encode_state != 7) {
>                     encode_state++;
>                 } else {
>                     encode_state = 0;
>                 }
>         }
>     } /* end compress_rref */
> }
> 
> /* Compresses a generator matrix in RREF into an array of bytes */
> void compress_c1s(uint8_t *compressed_c1s,
>                    const FQ_ELEM c1s[W][K_pad]) {
>     int compress_idx = 0;
> 
>     // Compress non-pivot columns row-by-row
>     int encode_state = 0;
>     for (uint32_t row_idx = 0; row_idx < W; row_idx++) {
>         for (uint32_t chal1_index = 0; chal1_index < K; chal1_index++) {
>                 switch (encode_state) {
>                     case 0:
>                         compressed_c1s[compress_idx] = c1s[row_idx][chal1_index];
>                         break;
>                     case 1:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 7);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 1);
>                         break;
>                     case 2:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 6);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 2);
>                         break;
>                     case 3:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 5);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 3);
>                         break;
>                     case 4:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 4);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 4);
>                         break;
>                     case 5:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 3);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 5);
>                         break;
>                     case 6:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 2);
>                         compress_idx++;
>                         compressed_c1s[compress_idx] = (c1s[row_idx][chal1_index] >> 6);
>                         break;
>                     case 7:
>                         compressed_c1s[compress_idx] =
>                                 compressed_c1s[compress_idx] | (c1s[row_idx][chal1_index] << 1);
>                         compress_idx++;
>                         break;
>                 }
> 
>                 if (encode_state != 7) {
>                     encode_state++;
>                 } else {
>                     encode_state = 0;
>                 }
>         }
>     } /* end compress_rref */
> }
> 
> /* Expands a compressed RREF generator matrix into a full one */
> void expand_c1s(FQ_ELEM c1s[W][K_pad],
>                 uint8_t *compressed_c1s){
>     int compress_idx = 0;
> 
>     // Decompress columns row-by-row
>     int decode_state = 0;
>     for (uint32_t row_idx = 0; row_idx < W; row_idx++) {
>         for (uint32_t chal1_index = 0; chal1_index < K; chal1_index++) {
>                 // Decompress non-pivot
>                 switch (decode_state) {
>                     case 0:
>                         c1s[row_idx][chal1_index] = compressed_c1s[compress_idx] & MASK_Q;
>                         break;
>                     case 1:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 7) |
>                                  (compressed_c1s[compress_idx + 1] << 1)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 2:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 6) |
>                                  (compressed_c1s[compress_idx + 1] << 2)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 3:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 5) |
>                                  (compressed_c1s[compress_idx + 1] << 3)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 4:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 4) |
>                                  (compressed_c1s[compress_idx + 1] << 4)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 5:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 3) |
>                                  (compressed_c1s[compress_idx + 1] << 5)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 6:
>                         c1s[row_idx][chal1_index] =
>                                 ((compressed_c1s[compress_idx] >> 2) |
>                                  (compressed_c1s[compress_idx + 1] << 6)) &
>                                 MASK_Q;
>                         compress_idx++;
>                         break;
>                     case 7:
>                         c1s[row_idx][chal1_index] =
>                                 (compressed_c1s[compress_idx] >> 1) & MASK_Q;
>                         compress_idx++;
>                         break;
>                 }
> 
>                 if (decode_state != 7) {
>                     decode_state++;
>                 } else {
>                     decode_state = 0;
>                 }
>         }
>     }
> 
> } /* end expand_to_rref */
